---
title: Exam 1 review
subtitle: Questions
format:
  html: default
  pdf: 
    linkcolor: "black"
execute:
  echo: false
---

```{r}
#| label: load-packages
#| message: false
library(tidyverse)
library(openintro)
library(scales)
library(palmerpenguins)
library(nycflights13)
library(gt)
library(janitor)
library(knitr)
```

```{r}
#| label: blizzard-data-prep
blizzard_salary <- blizzard_salary |>
  mutate(
    annual_salary = case_when(
      salary_type == "week" ~ current_salary * 52,
      salary_type == "hour" ~ current_salary * 40 * 52,
      TRUE ~ current_salary
    ),
    performance_rating = if_else(performance_rating == "Developing", "Poor", performance_rating)
  ) |>
  filter(salary_type != "week") |>
  mutate(
    salary_type = if_else(salary_type == "hour", "Hourly", "Salaried")
  ) |>
  filter(!is.na(annual_salary)) |>
  select(percent_incr, salary_type, annual_salary, performance_rating)
```

::: callout-note
Suggested answers can be found [here](/exam-review/exam-1-review-A.qmd), but resist the urge to peek before you go through it yourself.
:::

## Blizzard salaries

In 2020, employees of Blizzard Entertainment circulated a spreadsheet to anonymously share salaries and recent pay increases amidst rising tension in the video game industry over wage disparities and executive compensation.
(Source: [Blizzard Workers Share Salaries in Revolt Over Pay](https://www.bloomberg.com/news/articles/2020-08-03/blizzard-workers-share-salaries-in-revolt-over-wage-disparities))

The name of the data frame used for this analysis is `blizzard_salary` and the variables are:

-   `percent_incr`: Raise given in July 2020, as percent increase with values ranging from 1 (1% increase to 21.5 (21.5% increase)

-   `salary_type`: Type of salary, with levels `Hourly` and `Salaried`

-   `annual_salary`: Annual salary, in USD, with values ranging from \$50,939 to \$216,856.

-   `performance_rating`: Most recent review performance rating, with levels `Poor`, `Successful`, `High`, and `Top`.
    The `Poor` level is the lowest rating and the `Top` level is the highest rating.

The top ten rows of `blizzard_salary` are shown below:

```{r}
blizzard_salary |>
  select(percent_incr, salary_type, annual_salary, performance_rating)
```

### Question 1

Which of the following is [**correct**]{.underline}?
Choose all that apply.

a.  The `blizzard_salary` dataset has 399 rows.

b.  The `blizzard_salary` dataset has 4 columns.

c.  Each row represents a Blizzard Entertainment worker who filled out the spreadsheet.

d.  The `percent_incr` variable is numerical and discrete.

e.  The `salary_type` variable is numerical.

f.  The `annual_salary` variable is numerical.

g.  The `performance_rating` variable is categorical and ordinal.

::: {.content-visible when-format="pdf"}
$\vspace{1cm}$
:::

### Question 2

@fig-blizzard-hist-1 and @fig-blizzard-hist-2 show the distributions of annual salaries of hourly and salaried workers.
The two figures show the same data, with the facets organized across rows and across columns.
Which of the two figures is better for comparing the median annual salaries of hourly and salaried workers.
Explain your reasoning.

::: {#fig-blizzard-hist}
```{r}
#| label: fig-blizzard-hist-1
#| fig-cap: Option 1
#| fig-width: 8
#| fig-asp: 0.5
ggplot(blizzard_salary, aes(x = annual_salary)) +
  geom_histogram(binwidth = 10000, color = "white") +
  facet_wrap(~salary_type, ncol = 1) +
  scale_x_continuous(labels = label_dollar(scale = 1/1000, suffix = "K"), breaks = seq(0, 250000, 25000)) +
  labs(
    x = "Annual salary (in USD)",
    y = "Count"
  )
```

```{r}
#| label: fig-blizzard-hist-2
#| fig-cap: Option 2
#| fig-width: 8
#| fig-asp: 0.3

ggplot(blizzard_salary, aes(x = annual_salary)) +
  geom_histogram(binwidth = 10000, color = "white") +
  facet_wrap(~salary_type, nrow = 1) +
  scale_x_continuous(labels = label_dollar(scale = 1/1000, suffix = "K"), breaks = seq(0, 250000, 25000)) +
  labs(
    x = "Annual salary (in USD)",
    y = "Count"
  )
```

Distribution of annual salaries of Blizzard employees
:::

{{< pagebreak >}}

### Question 3

Suppose your teammate wrote the following code as part of their analysis of the data.

```{r}
#| label: blizzard-summarize
#| results: false
blizzard_salary |>
  group_by(salary_type) |>
  summarize(
    mean_annual_salary = mean(annual_salary),
    median_annual_salary = median(annual_salary)
  )
```

They then printed out the results shown below.
Unfortunately one of the numbers got erased from the printout.
It's indicated with `_____` below.

```         
# A tibble: 2 Ã— 3
  salary_type mean_annual_salary median_annual_salary
  <chr>                    <dbl>                <dbl>
1 Hourly                  63003.               54246.
2 Salaried                90183.               _____
```

Which of the following is the best estimate for that erased value?

a.  30,000

b.  50,000

c.  80,000

d.  100,000

### Question 4

Which distribution of annual salaries has a higher standard deviation?

a.  Hourly workers

b.  Salaried workers

c.  Roughly the same

{{< pagebreak >}}

### Question 5

Which of the following alternate plots would also be useful for visualizing the distributions of annual salaries of hourly and salaried workers?
Choose all that apply.

a\.
Box plots

b\.
Density plots

c\.
Pie charts

d\.
Waffle charts

e\.
Histograms

f\.
Scatterplots

{{< pagebreak >}}

### Questions 6 and 7

Suppose you made the bar plot shown in @fig-performance-rating-1 to visualize the distribution of `performance_rating` and your teammate made the bar plot shown in @fig-performance-rating-2.

```{r}
#| label: fig-performance-rating
#| layout-ncol: 2
#| fig-cap: Distribution of performance rating
#| fig-width: 5
#| fig-asp: 0.5
#| fig-subcap: 
#|   - Option 1
#|   - Option 2

ggplot(blizzard_salary, aes(x = performance_rating)) +
  geom_bar() +
  labs(
    x = "Performance rating", y = "Count",
    title = "Performance rating of Blizzard employees"
  )

blizzard_salary |>
  mutate(performance_rating = fct_relevel(performance_rating, "Poor", "Successful", "High", "Top")) |>
  ggplot(aes(x = performance_rating)) +
  geom_bar() +
  labs(
    x = "Performance rating", y = "Count",
    title = "Performance rating of Blizzard employees"
  )
```

You made your bar plot without transforming the data in any way, while your friend did first transform the data with code like the following:

```{r}
#| eval: false
#| echo: true

blizzard_salary <- blizzard_salary |>
  _(1)_(performance_rating = fct_relevel(performance_rating, _(2)_))
```

**Question 6:** What goes in the blank (1)?

a.  `arrange()`

b.  `filter()`

c.  `mutate()`

d.  `summarize()`

**Question 7:** What goes in the blank (2)?

a.  `"Poor", "Successful", "High", "Top"`

b.  `"Successful", "High", "Top"`

c.  `"Top", "High", "Successful", "Poor"`

d.  `Poor, Successful, High, Top`

{{< pagebreak >}}

### Questions 8 - 10

Finally, another teammate creates the following two plots.

```{r}
#| label: fig-salary-performance-rating
#| layout-ncol: 2
#| fig-cap: Distribution of salary type by performance rating
#| fig-width: 5
#| fig-asp: 0.5
#| fig-subcap: 
#|   - Option 1
#|   - Option 2

blizzard_salary |>
  drop_na(salary_type, performance_rating) |>
  ggplot(aes(x = salary_type, fill = fct_rev(performance_rating))) +
  geom_bar() +
  scale_fill_viridis_d() +
  labs(
    x = "Salary type",
    y = "Count",
    fill = "Performance\nrating"
  )

blizzard_salary |>
  drop_na(salary_type, performance_rating) |>
  ggplot(aes(x = salary_type, fill = fct_rev(performance_rating))) +
  geom_bar(position = "fill") +
  scale_fill_viridis_d() +
  labs(
    x = "Salary type",
    y = "Proportion",
    fill = "Performance\nrating"
  )
```

**Question 8:** Your teammate asks you for help deciding which one to use in the final report for visualizing the relationship between performance rating and salary type.
In 1-3 sentences, can you help them make a decision, justify your choice, and write the narrative that should go with the plot?

::: {.content-visible when-format="pdf"}
$\vspace{2cm}$
:::

**Question 9:** A friend with a keen eye points out that the number of observations in @fig-salary-performance-rating-1 seems lower than the total number of observations in `blizzard_salary`.
What might be going on here?
Explain your reasoning.

::: {.content-visible when-format="pdf"}
$\vspace{2cm}$

{{< pagebreak >}}
:::

**Question 10:** Below are the proportions of performance ratings for hourly and salaried workers.
Place these values in the corresponding segments in @fig-salary-performance-rating-2.

```{r}
#| label: salary-type-perfecormance-table

blizzard_salary |>
  drop_na(salary_type, performance_rating) |>
  count(salary_type, performance_rating) |>
  pivot_wider(names_from = salary_type, values_from = n, values_fill = 0) |>
  mutate(across(-performance_rating, ~ .x / sum(.x)))
```

::: {.content-visible when-format="pdf"}
{{< pagebreak >}}
:::

### Questions 11 and 12

The table below shows the distribution of `salary_type` and `performance_rating`.

```{r}
blizzard_salary |>
  count(salary_type, performance_rating) |>
  pivot_wider(names_from = performance_rating, values_from = n) |>
  select(salary_type, Poor, Successful, High, Top, `NA`)
```

The pipeline below produces a data frame with a fewer number of rows than `blizzard_salary`.

```{r}
#| eval: false
#| echo: true
blizzard_salary |>
  filter(salary_type _(1)_ "Hourly" _(2)_ performance_rating == "Poor") |>
  _(3)_(annual_salary)
```

```{r}
#| echo: false
blizzard_salary |>
  filter(salary_type != "Hourly" & performance_rating == "Poor") |>
  arrange(annual_salary)
```

**Question 11:** Which of the following goes in blanks (1) and (2)?

|     | \(1\) | \(2\) |
|-----|:-----:|:-----:|
| a\. | `!=`  |  `|`  |
| b\. | `==`  |  `&`  |
| c\. | `!=`  |  `&`  |
| d\. | `==`  |  `|`  |

::: {.content-visible when-format="pdf"}
$\vspace{1cm}$
:::

**Question 12:** Which function or functions go into blank (3)?

a.  `arrange()`

b.  `mutate()`

c.  `order()`

d.  `sort()`

::: {.content-visible when-format="pdf"}
$\vspace{1cm}$
:::

### Question 13

You're reviewing another team's work and they made the following visualization:

```{r}
#| warning: false
#| fig-width: 10
#| fig-asp: 0.5

ggplot(blizzard_salary, aes(x = annual_salary, percent_incr)) +
  geom_point() +
  facet_wrap(~performance_rating)
```

And they wrote the following interpretation for the relationship between annual salary and percent increase for Top performers:

> The relationship is positive, having a higher salary results in a higher percent increase.
> There is one clear outlier.

Which of the following is/are the most accurate and helpful) peer review note for this interpretation.
Choose all that apply.

a.  The interpretation is complete and perfect, no changes needed!

b.  The interpretation doesn't mention the direction of the relationship.

c.  The interpretation doesn't mention the form of the relationship, which is linear.

d.  The interpretation doesn't mention the strength of the relationship, which is somewhat strong.

e.  There isn't a clear outlier in the plot.
    If any points stand out as potential outliers, more guidance should be given to the reader to identify them (e.g., salary and/or percent increase amount).

f.  The interpretation is causal â€“ we don't know if the cause of the high percent increase is higher annual salary based on observational data.
    The causal direction might be the other way around, or there may be other factors contributing to the apparent relationship.

::: {.content-visible when-format="pdf"}
$\vspace{2cm}$

{{< pagebreak >}}
:::

### Question 14

Below is some code and its output.

```{{r}}
# label=plot blizzard

ggplot(blizzard_salary,aes(x=performance_rating,y=percent_incr))+geom_boxplot()
labs(x="Performance rating", y = "Percent increase")
```

```{r}
#| echo: false
#| fig-width: 8
#| fig-asp: 0.4

ggplot(blizzard_salary,aes(x=performance_rating,y=percent_incr))+geom_boxplot()
labs(x="Performance rating", y = "Percent increase")
```

Part 1: List at least 5 things that should be fixed or improved in the code.

::: {.content-visible when-format="pdf"}
$\vspace{5cm}$
:::

Part 2: What is the cause of the warning and what does it mean?

{{< pagebreak >}}

### Question 15

You're working on a data analysis on salaries of Blizzard employees in a Quarto document in a project version controlled by Git.
You create a plot and write up a paragraph describing any patterns in it.
Then, your teammate says "render, commit, and push".

Part 1: What do they mean by each of these three steps.
In 1-2 sentences for each, explain in your own words what they mean.

1.  Render:

::: {.content-visible when-format="pdf"}
$\vspace{2cm}$
:::

2.  Commit:

::: {.content-visible when-format="pdf"}
$\vspace{2cm}$
:::

3.  Push:

::: {.content-visible when-format="pdf"}
$\vspace{2cm}$
:::

Part 2: Your teammate is getting impatient and they interrupt you after you rendered and committed and say "I still can't see your changes in our shared GitHub repo when I look at it in my web browser." Which of the following answers is the most accurate?

a.  I rendered my document, you should be seeing my changes on GitHub when you look at it in your web browser.

b.  I committed my changes, you should be seeing my changes on GitHub when you look at it in your web browser.

c.  I didn't yet push my changes, it's expected that you are not seeing them on GitHub when you look at it in your web browser.
    Wait until I push, and check again.

d.  You need to pull to see my changes on GitHub in the web browser.

## Penguins

The `penguins` data set includes measurements for penguin species, including: flipper length, body mass, bill dimensions, and sex. The following table summarizes information on which species of penguins (Adelie, Gentoo, and Chinstrap) live on which islands (Biscoe, Dream, or Torgersen).

```{r}
#| label: penguins-species-island-table
#| echo: false

penguins |>
  count(island, species) |>
  pivot_wider(names_from = species, values_from = n, values_fill = 0) |>
  rename(Island = island) |>
  janitor::adorn_totals(where = c("row", "col")) |>
  gt() |>
  cols_align(align = "right")
```

### Question 16

Which of the following plots is the result of the following code?

```{r}
#| label: penguins-species-island-bar-code
#| fig-show: hide

ggplot(penguins, aes(x = island, fill = species)) + 
  geom_bar()
```

```{r}
#| label: penguins-species-island-bar-plots
#| layout-ncol: 2
#| fig-width: 5
#| fig-asp: 0.6
#| echo: false

ggplot(penguins, aes(x = island, fill = species)) + 
  geom_bar(position = "fill", color = "black") +
  labs(title = "(a)", x = "Island", y = "Proportion", fill = "Species") +
  scale_fill_grey(start = 0.8, end = 0)

ggplot(penguins, aes(fill = island, x = species)) + 
  geom_bar(position = "fill", color = "black") +
  labs(title = "(b)", fill = "Island", y = "Proportion", x = "Species") +
  scale_fill_grey(start = 0.8, end = 0)

ggplot(penguins, aes(fill = island, y = species)) + 
  geom_bar(position = "fill", color = "black") +
  labs(title = "(c)", fill = "Island", x = "Proportion", y = "Species") +
  scale_fill_grey(start = 0.8, end = 0)

ggplot(penguins, aes(x = island, fill = species)) + 
  geom_bar(color = "black") +
  labs(title = "(d)", x = "Island", fill = "Species", y = "Count") +
  scale_fill_grey(start = 0.8, end = 0)

ggplot(penguins, aes(fill = island, y = species)) + 
  geom_bar(color = "black") +
  labs(title = "(e)", fill = "Island", y = "Species", x = "Count") +
  scale_fill_grey(start = 0.8, end = 0)
```

## NYC Flights

The `flights` dataset includes characteristics of all flights departing from New York City airports (JFK, LGA, EWR) in 2013. Below is a peek at the first ten rows of the `flights` data.

```{r}
#| label: flights-glimpse

flights |>
  relocate(year, month, day, arr_delay, carrier)
```

### Question 17

Based on this output, which of the following must be [**true**]{.underline} about the `flights` data frame? **Select all that are true.**

a.  The `flights` data frame is a `tibble`.

b.  The `flights` data frame has 10 rows.

c.  The `flights` data frame has 8 columns.

d.  The `carrier` variable in the `flights` data frame is a character variable.

e.  There are no missing data in the `flights` data frame.

### Question 18

Which of the following pipelines produce(s) the output shown below? **Select all that apply.**

```{r}
#| label: flights-pipeline
#| echo: false

flights |>
  select(arr_delay, carrier, year, month, day) |>
  arrange(desc(arr_delay))
```

a\.

```{r}
#| echo: true
#| eval: false
flights |>
  select(arr_delay, carrier, year, month, day) |>
  arrange(desc(arr_delay))
```

b\.

```{r}
#| label: flights-pipeline-alt-1
#| eval: false
#| echo: true

flights |>
  select(arr_delay, carrier, year, month, day) |>
  arrange(arr_delay)
```

c\.

```{r}
#| label: flights-pipeline-alt-2
#| eval: false
#| echo: true

flights |>
  select(arr_delay, carrier, year, month, day) |>
  arrange(year)
```

d\.

```{r}
#| label: flights-pipeline-alt-3
#| eval: false
#| echo: true
flights |>
  arrange(desc(arr_delay)) |>
  select(arr_delay, carrier, year, month, day)
```

e\.

```{r}
#| label: flights-pipeline-alt-4
#| eval: false
#| echo: true
flights |>
  arrange(desc(arr_delay)) |>
  select(day, month, year, arr_delay, carrier)
```

## Countries and populations

```{r}
#| label: load-pop-data
#| echo: false
#| message: false

population_raw <- read_csv("data/world-pop-2022.csv")
continents_raw <- read_csv("data/continents.csv")
```

```{r}
#| label: prep-pop-data
#| echo: false

set.seed(12345)
population <- population_raw |>
  sample_n(size = 6) |>
  select(!year) |>
  arrange(country)
continents <- continents_raw |>
  select(!year) |>
  semi_join(population, join_by(entity == country)) |>
  slice_head(n = 4) |>
  bind_rows(tibble(entity = "Angola", code = "AGO", continent = "Africa")) |>
  arrange(entity)
```

We have a small dataset of six countries and their populations:

```{r}
population
```

And another small dataset of five countries and the continent they're in:

```{r}
continents
```

You join the two datasets with the following:

```{r}
#| label: join-code
#| results: hide

population |>
  left_join(continents, by = join_by(country == entity))
```

### Question 19

How many rows will the resulting data frame have?

a.  4
b.  5
c.  6
d.  7
e.  8

### Question 20

What will be the columns of the resulting data frame?

a.  `country`, `population`

b.  `country`, `population`, `code`, `continent`

c.  `entity`, `code`, `continent`

d.  `entity`, `population`, `code`, `continent`

e.  `country`, `entity`, `population`, `code`, `continent`

## Duke Forest houses

The `duke_forest` dataset includes information on prices and various other features (number of bedrooms, bathrooms, area, year built, type of cooling, type of heating, etc.) of houses in the Duke Forest neighborhood of Durham, NC.

```{r}
glimpse(duke_forest)
```

The following summary table gives us some information about whether homes in this data set have garages and when they were built.

```{r}
#| label: duke-forest
#| echo: false

duke_forest <- duke_forest |>
  mutate(
    parking = if_else(str_detect(parking, "Garage"), "Garage", "No garage"),
    year_built_cat = if_else(year_built < 1950, "Built earlier than 1950", "Built in 1950 or later")
  )

duke_forest |>
  count(parking, year_built_cat) |>
  pivot_wider(names_from = year_built_cat, values_from = n, values_fill = 0) |>
  rename(" " = "parking") |>
  gt()
```

The pipeline below produces a data frame with a fewer number of rows than `duke_forest`.

```{r}
#| label: duke-forest-pipeline-blanks
#| eval: false

duke_forest |>
  filter(parking == "Garage" _(1)_ year_built _(2)_ 1950) |>
  select(parking, year_built, price, area) |>
  _(3)_(price_per_sqfeet = price / area)
```

```{r}
#| label: duke-forest-pipeline
#| echo: false

duke_forest |>
  filter(parking == "Garage" & year_built < 1950) |>
  select(parking, year_built, price, area) |>
  mutate(price_per_sqfeet = price / area)
```

### Question 21

Which of the following goes in blanks (1) and (2)?

|     | \(1\) | \(2\) |
|-----|:-----:|:-----:|
| a\. |  `&`  |  `<`  |
| b\. |  `|`  |  `<`  |
| c\. |  `&`  | `>=`  |
| d\. |  `|`  | `>=`  |
| e\. |  `&`  | `!=`  |

### Question 22

Which function or functions go into blank (3)? **Select all that apply.**

a.  `arrange()`

b.  `mutate()`

c.  `filter()`

d.  `summarize()`

e.  `slice()`

## Law & Order

You've heard of the tidyverse, now let's visit the Law & Order-verse. Doink doink![^1]

[^1]: "Doink doink" is the scene and episode introductory sound on the Law & Order series. If you've never heard it, you're not at any disadvantage for the exam. If you've ever heard it, good luck getting it out of your head!

Law & Order is a police procedural and legal drama television series that has been running since the 1990s. The Law & Order franchise includes a number of series such as Law & Order, Law & Order: SVU, Law & Order: Criminal Intent, etc.

You will work with data on average ratings for each season of three series from the Law & Order-verse â€“ a subset of the data from the previous questions. Below is a peek at the first ten rows of the Law & Order data.

```{r}
#| echo: false
#| message: false
tv <- read_csv("data/tv.csv")
law_and_order <- tv |>
  filter(str_detect(title, "Law & Order"))
```

The plot below shows the distributions of average ratings of various Law & Order series across seasons.

```{r}
#| echo: false
#| fig-asp: 0.35
#| fig-width: 8

law_and_order |>
  mutate(title = str_replace(title, "Law & Order: ", "Law & Order:\n")) |>
  ggplot(aes(x = av_rating, y = fct_rev(title))) +
  geom_boxplot(alpha = 0.5, show.legend = FALSE, outlier.size = 2) +
  labs(x = "Average rating", y = "Series title")
```

### Question 23

Based on the information from the side-by-side box plots, fill in the legend of the plot below with Law & Order series titles.

```{r}
#| echo: false
#| fig-asp: 0.35
#| fig-width: 8
#| warning: false

ggplot(law_and_order, aes(x = season, y = av_rating, shape = title)) +
  geom_line(linewidth = 0.3) +
  geom_point(size = 3) +
  scale_shape_manual(
    values = c("Law & Order: SVU" = "triangle", 
               "Law & Order: Criminal Intent" = "diamond", 
               "Law & Order: True Crime" = "square", 
               "Law & Order" = "asterisk", 
               "Law & Order: LA" = "circle"), 
    labels = c("__________________________________",
               "__________________________________",
               "__________________________________",
               "__________________________________",
               "__________________________________")
  ) +
  labs(
    x = "Season",
    y = "Average rating",
    shape = "Series title"
  ) +
  theme(legend.key.height = unit(1.25, "cm"))
```

### Question 24

The following code calculates the standard deviations of average season ratings of the five Law & Order series. Unfortunately, the output is partially erased and replaced with blanks.

```{r}
#| results: hide

lo_titles <- c("Law & Order", "Law & Order: Criminal Intent", "Law & Order: SVU")

law_and_order |>
  filter(title %in% lo_titles) |>
  group_by(title) |>
  summarize(mean_av_rating = mean(av_rating), sd_av_rating = sd(av_rating))
```

```         
# A tibble: 5 Ã— 3
  title                         mean_av_rating sd_av_rating
  <chr>                                  <dbl>        <dbl>
1 Law & Order                            _(1)_        0.106
2 Law & Order: Criminal Intent            8.20        0.129
4 Law & Order: SVU                        8.67        _(2)_
```

Based on the visualizations you've seen of these data so far, which of the following is [**true**]{.underline} about the blanks in the output? **Select all that are true.**

a.  The **mean** of average ratings (Blank 1) of Law & Order seasons is **lower** than the other two means.

b.  The **mean** of average ratings (Blank 1) of Law & Order seasons is **higher** than the other two means.

c.  The **standard deviation** of average ratings of Law & Order: SVU seasons (Blank 2) is **lower** than the other two standard deviations.

d.  The **standard deviation** of average ratings of Law & Order: SVU seasons (Blank 2) is **higher** than the other two standard deviations.

e.  The **standard deviation** of average ratings of Law & Order: SVU seasons (Blank 2) is **between** the other two standard deviations.

## Romance and comedy

Finally, we focus on romance and comedy shows. We first filter the dataset for any shows that have romance or comedy as their genre (`genre_1`, `genre_2`, or `genre_3`) and then remove shows that have both of these genre labels. For the next two questions, we focus on these shows that we identify as either romance or comedy. We then calculate the mean of the average season ratings for each show, to obtain a single "mean average rating" value per show.

```{r}
#| echo: false

romance_shows <- tv |>
  filter(genre_1 == "Romance" | genre_2 == "Romance" | genre_3 == "Romance") |>
  distinct(title) |>
  pull()

comedy_shows <- tv |>
  filter(genre_1 == "Comedy" | genre_2 == "Comedy" | genre_3 == "Comedy") |>
  distinct(title) |>
  pull()

romance_comedy <- tv |>
  filter(title %in% c(romance_shows, comedy_shows)) |>
  filter(!(title %in% romance_shows & title %in% comedy_shows)) |>
  mutate(
    genre = if_else(title %in% romance_shows, "Comedy", "Romance")
  ) |>
  select(-genre_1, -genre_2, -genre_3)

romance_comedy_means <- romance_comedy |>
  group_by(genre, title) |>
  summarize(mean_av_rating = mean(av_rating), .groups = "drop")
```

The plot below shows the distributions of mean average ratings of seasons of comedy and romance shows.

```{r}
#| echo: false
#| fig-asp: 0.6

ggplot(romance_comedy_means, aes(x = mean_av_rating, fill = genre)) +
  geom_histogram(binwidth = 0.25, show.legend = FALSE, color = "white") +
  facet_wrap(~genre, nrow = 2) +
  labs(x = "Mean average rating", y = "Count") +
  scale_fill_grey(start = 0.2, end = 0.6)
```

### Question 25

Which of the following statements is [**true**]{.underline} about these distributions? **Select all that are true.**

a.  Mean average ratings of romance shows are bimodal.
b.  Mean average ratings of comedy are unimodal.
c.  Mean average ratings of romance shows is left skewed.
d.  Mean average ratings of comedy shows is right skewed.
e.  There are more romance shows than comedy shows.

## IMDB

The data for the next few questions come from the Internet Movie Database (IMDB). Specifically, the data are a random sample of movies released between 1980 and 2020.

```{r}
#| label: load-data
#| message: false
movies <- read_csv("data/movies.csv")
```

The name of the data frame used for this analysis is `movies`, and it contains the variables shown in @tbl-data-dictionary.

\setcounter{table}{0}

| Variable          | Description                                                             |
|-----------------------|-------------------------------------------------|
| `name`            | name of the movie                                                       |
| `rating`          | rating of the movie (R, PG, etc.)                                       |
| `genre`           | main genre of the movie.                                                |
| `runtime`         | duration of the movie                                                   |
| `year`            | year of release                                                         |
| `release_date`    | release date (YYYY-MM-DD)                                               |
| `release_country` | release country                                                         |
| `score`           | IMDB user rating                                                        |
| `votes`           | number of user votes                                                    |
| `director`        | the director                                                            |
| `writer`          | writer of the movie                                                     |
| `star`            | main actor/actress                                                      |
| `country`         | country of origin                                                       |
| `budget`          | the budget of a movie (some movies don't have this, so it appears as 0) |
| `gross`           | revenue of the movie                                                    |
| `company`         | the production company                                                  |

: Data dictionary for `movies` {#tbl-data-dictionary tbl-colwidths="\[20,80\]"}

The first thirty rows of the `movies` data frame are shown in @tbl-data, with variable types suppressed (since we'll ask about them later).

```{r}
#| echo: false
movies_to_mark <- c("Blue City", "Rang De Basanti", "Winter Sleep")

movies <- movies |>
  mutate(
    mark = if_else(name %in% movies_to_mark, TRUE, FALSE),
    rating = case_when(
      rating == "TV-PG" ~ "PG",
      rating == "Unrated" ~ "Not Rated",
      is.na(rating) ~ "Not Rated",
      .default = rating
    ),
    rating = fct_relevel(rating, "G", "PG", "PG-13", "R", "NC-17", "Not Rated")
  ) |>
  arrange(desc(mark)) |>
  relocate(name, score, runtime, genre, rating, release_country, release_date, budget, gross, votes, year, director, writer, star, company, country)
```

::: {#tbl-data}
First 30 rows of `movies`, with variable types suppressed.

```{r}
#| echo: false
options(
  dplyr.print_min = 30,
  pillar.min_chars = 13,
  pillar.width = 110,
  pillar.sigfig = 6
)

format(movies |> select(!c(mark)))[-3L] |>
  str_remove_all(" <.*?>") |>
  cat(sep = "\n")

options(
  dplyr.print_min = 10,
  pillar.min_chars = 8,
  pillar.width = 80,
  pillar.sigfig = 3
)
```
:::

### Question 26

The `name` and `runtime` variables are shown below, with the variable types suppressed.

::: {layout="[0.5, 0.5]"}
::: {#firstcol}
```{r}
#| eval: false
movies |>
  select(name, runtime)
```

```{r}
#| echo: false

options(dplyr.print_min = 6)

format(as_tibble(movies |> select(name, runtime)))[-3L] |>
  str_remove_all(" <.*?>") |>
  cat(sep = "\n")

options(dplyr.print_min = 10)
```
:::

::: {#secondcol}
What is the type of the `runtime` variable?

a.  Character

b.  Double

c.  Factor

d.  Integer

e.  Logical
:::
:::

\vspace{2cm}

### Question 27

The code below summarizes the data in a certain way.

```{r}
movies |>
  summarize(sum(release_country == "United States"))
```

Which of the following is [**TRUE**]{.underline} about the code and its result? **Select all that are true.**

a.  Evaluates whether each `release_country` is equal to `"United States"` or not, which results in a logical variable.

b.  Filters out rows where `release_country` is not equal to `"United States"` and counts the remaining rows.

c.  Sums the logical values, where each `TRUE` is considered a 1 and each `FALSE` is considered a 0.

d.  Results in a character vector.

e.  The result shows there are 435 movies released in the United States.

### Question 28

Suppose you want a visualization that shows the number of movies in the sample in each `genre`. Your first attempt is as follows.

```{r}
#| fig-width: 6
#| fig-asp: 0.4
ggplot(movies, aes(x = genre)) +
  geom_bar()
```

A friend of yours says that the visualization is difficult to read and they suggest using the following visualization instead.

```{r}
#| echo: false
#| fig-width: 6
#| fig-asp: 0.4
movies <- movies |>
  mutate(
    genre = fct_other(genre, keep = c("Action", "Comedy", "Drama", "Horror")),
    genre = fct_relevel(genre, "Other", "Horror", "Drama", "Action", "Comedy")
  )

ggplot(movies, aes(y = genre)) +
  geom_bar(show.legend = FALSE) +
  labs(
    x = "Number of movies",
    y = "Genre",
    title = "Movies and genres",
    caption = "Source: IMDB."
  )
```

Which of the following modifications would your friend have made to your code to create their version? **Select all that apply.**

a.  Combine movies in genres other than Comedy, Drama, Action, and Horror into a new level called `"Other"`.

b.  Reorder the levels in descending order of numbers of observations, except for the `"Other"` level.

c.  Map `genre` to the `y` aesthetic.

d.  Add a title, x and y-axis labels, and a caption.

e.  Filter out all moves in genres other than Comedy, Drama, Action, and Horror before plotting.

### Question 29

Which of the following is [**TRUE**]{.underline} about the code and its result? **Select all that are true.**

```{r}
movies |>
  count(rating, genre) |>
  pivot_wider(names_from = genre, values_from = n, values_fill = 0)
```

a.  The code counts how many movies are in each rating and genre combination.

b.  The code sorts the results in descending order.

c.  Each row of the output is a movie.

d.  The output shows that there are six distinct ratings in the dataset.

e.  The code reduces the number of variables and observations in the `movies` data frame to six.

## Bonus

Pick a concept we introduced in class so far that you've been struggling with and explain it in your own words.
